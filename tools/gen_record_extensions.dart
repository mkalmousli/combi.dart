#!/usr/bin/env dart

import 'dart:io';

import 'package:path/path.dart';

const startCount = 2;
const endCount = 30;

final autoGenerated = "// Auto generated by `${fThis.name}`. Do not modify!";

final fThis = Platform.script.toFilePath().file;
final dThis = fThis.parent;
final dTools = dThis;
final dRoot = dTools.parent;

final dLib = dRoot.d("lib");
final fOut = dLib.d("generated").f("record_extensions.dart");

extension on String {
  Directory get dir => Directory(this);
  File get file => File(this);
}

extension on Directory {
  File f(String path) => join(this.path, path).file;
  Directory d(String path) => join(this.path, path).dir;
}

extension on FileSystemEntity {
  String get name => basename(path);
}

extension on IOSink {
  void w(String s) => write(s);
  void nl() => w("\n");
  void l(String s) {
    w(s);
    nl();
  }

  void i([int level = 1]) => w('\t' * level);
}

extension on int {
  Iterable<int> iter({int start = 0}) sync* {
    for (int i = start; i < this + start; i++) {
      yield i;
    }
  }
}

void main(List<String> args) async {
  await fOut.parent.create(recursive: true);

  final wOut = fOut.openWrite(mode: FileMode.write);
  wOut.l(autoGenerated);

  wOut.l("// ignore_for_file: type=lint");
  wOut.l(
    "// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark",
  );
  wOut.l("import 'package:combi/combi.dart' as p;");

  for (int iExt = startCount; iExt <= endCount; iExt++) {
    wOut.w("extension RecordOf${iExt}ParsersExt");
    wOut.w("<");
    wOut.w(iExt.iter().map((n) => "T$n").join(", "));
    wOut.w(">");

    wOut.w(" on (");
    wOut.w(iExt.iter().map((n) => "p.Parser<T$n>").join(", "));
    wOut.l(") {");

    wOut.i();
    wOut.w("p.Parser<(");
    wOut.w(iExt.iter().map((n) => "T$n").join(", "));
    wOut.w(")> toParser() => p.list([");
    wOut.w(iExt.iter(start: 1).map((n) => "\$$n").join(", "));
    wOut.w("]).map((v) => (");
    wOut.w(iExt.iter().map((n) => "v[$n] as T$n").join(", "));
    wOut.l("));");

    wOut.i();
    wOut.w("p.Parser<dynamic> altDynamic() => p.alt([");
    wOut.w(iExt.iter(start: 1).map((n) => "\$$n").join(", "));
    wOut.l("]);");

    wOut.l("}");

    /// Extensions for parsers of the same type

    wOut.nl();
    wOut.w("extension RecordOf${iExt}ParsersExtSameType<T>");

    wOut.w(" on (");
    wOut.w(iExt.iter().map((n) => "p.Parser<T>").join(", "));
    wOut.l(") {");

    wOut.i();
    wOut.w("p.Parser<T> alt() => p.alt([");
    wOut.w(iExt.iter(start: 1).map((n) => "\$$n").join(", "));
    wOut.l("]);");
    wOut.l("}");

    /// Extensions for the record parser

    wOut.nl();
    wOut.w("extension E${iExt}ParsersExt");
    wOut.w("<");
    wOut.w(iExt.iter().map((n) => "T$n").join(", "));
    wOut.w(">");

    wOut.w(" on p.Parser<(");
    wOut.w(iExt.iter().map((n) => "T$n").join(", "));
    wOut.l(")> {");

    wOut.l(
      "\tp.Parser<T${iExt.iter().last}> get onlyLast => map((v) => v.\$$iExt);",
    );

    wOut.l("\tp.Parser<T0> get onlyFirst => map((v) => v.\$1);");

    for (final n in iExt.iter()) {
      wOut.i();
      wOut.l("p.Parser<T$n> get only${n + 1} => map((v) => v.\$${n + 1});");
    }

    wOut.l("}");
  }

  await wOut.close();
}
